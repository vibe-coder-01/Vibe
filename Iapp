# app.py
# Full Python translation of the Ion_Exchange_Model.R Shiny application.
# Includes Alkalinity and kL Guesser tabs.

import shiny
import shiny.experimental as x
from shiny import App, ui, render, reactive, req
from shiny.types import FileInfo
import shinyswatch
from shinywidgets import output_widget, render_widget

import pandas as pd
import numpy as np
from scipy.integrate import solve_ivp
from scipy.interpolate import interp1d
from scipy.special import roots_jacobi,sh_jacobi
import os
from pathlib import Path
import plotly.graph_objects as go

# =============================================================================
# Original R Code: Library Imports and Color Definitions
#
# library(readxl)
# library(shiny)
# library(shinythemes)
# library(deSolve)
# library(orthopolynom)
# library(plotly)
# library(shinyjs)
# library(tidyr)
# library(DataEditR)
# library(writexl)
# library(ggplot2)
# library(shinyalert)
#
# SteppedSequential5Steps <- c("#990F0F", "#B22C2C", "#CC5151", "#E57E7E", "#FFB2B2",
#                              "#99540F", "#B26F2C", "#CC8E51", "#E5B17E", "#FFD8B2",
#                              "#6B990F", "#85B22C", "#A3CC51", "#C3E57E", "#E5FFB2",
#                              "#0F6B99", "#2C85B2", "#51A3CC", "#7EC3E5", "#B2E5FF",
#                              "#260F99", "#422CB2", "#6551CC", "#8F7EE5", "#BFB2FF")
#
# Explanation of Python translation:
# The R libraries are mapped to their Python equivalents:
# - shiny, shinythemes, etc. -> shiny, shinyswatch
# - readxl, writexl -> pandas
# - deSolve -> scipy.integrate.solve_ivp
# - orthopolynom -> scipy.special
# - plotly -> plotly
# - tidyr -> pandas (for melt/pivot operations)
# The color vector is translated into a Python list.
# =============================================================================
STEPPED_SEQUENTIAL_5_STEPS = ["#990F0F", "#B22C2C", "#CC5151", "#E57E7E", "#FFB2B2",
                              "#99540F", "#B26F2C", "#CC8E51", "#E5B17E", "#FFD8B2",
                              "#6B990F", "#85B22C", "#A3CC51", "#C3E57E", "#E5FFB2",
                              "#0F6B99", "#2C85B2", "#51A3CC", "#7EC3E5", "#B2E5FF",
                              "#260F99", "#422CB2", "#6551CC", "#8F7EE5", "#BFB2FF"]

# =============================================================================
# Original R Code: Unit Conversions
#
# m2cm<-100, mm2cm<-0.1, ... etc.
#
# Explanation of Python translation:
# The R variables for unit conversions are translated into a Python dictionary
# for better organization and clarity. This avoids polluting the global namespace.
# =============================================================================
UNITS = {
    'm2cm': 100,
    'mm2cm': 0.1,
    'cm2cm': 1,
    'in2cm': 2.54,
    'ft2cm': 12 * 2.54,
    'sec2sec': 1,
    'min2sec': 60,
    'hour2sec': 3600,
    'day2sec': 24 * 3600,
    'month2sec': 30 * 24 * 3600,
    'year2sec': 365.25 * 24 * 3600,
    'gal2ft3': 0.133680555556,
    'l2ml': 1000.0,
    'gal2ml': 3785.411784
}
UNITS['mgd2mlps'] = 1e6 * UNITS['gal2ml'] / UNITS['day2sec']

# Conversion dictionaries
# The R code uses named vectors as dictionaries. Python's dictionaries are a direct equivalent.
LENGTH_CONV = {"m": UNITS['m2cm'], "cm": UNITS['cm2cm'], "mm": UNITS['mm2cm'], "in": UNITS['in2cm'], "ft": UNITS['ft2cm']}
VELOCITY_CONV = {
    "cm/s": UNITS['cm2cm'], "m/s": UNITS['m2cm'], "m/min": UNITS['m2cm'] / UNITS['min2sec'],
    "m/h": UNITS['m2cm'] / UNITS['hour2sec'], "m/hr": UNITS['m2cm'] / UNITS['hour2sec'],
    "in/s": UNITS['in2cm'], "ft/s": UNITS['ft2cm'], "ft/min": UNITS['ft2cm'] / UNITS['min2sec'],
    "gpm/ft^2": UNITS['gal2ft3'] * UNITS['ft2cm'] / UNITS['min2sec']
}
VOLUMETRIC_CONV = {
    "cm^3/s": UNITS['cm2cm'], "m^3/s": UNITS['m2cm']**3, "ft^3/s": UNITS['ft2cm']**3,
    "mL/s": UNITS['cm2cm'], "L/min": UNITS['l2ml'] / UNITS['min2sec'], "mL/min": 1 / UNITS['min2sec'],
    "gpm": UNITS['gal2ml'] / UNITS['min2sec'], "mgd": UNITS['mgd2mlps']
}
TIME_CONV = {"Hours": UNITS['hour2sec'], "Days": UNITS['day2sec'], "Months": UNITS['month2sec'], "Years": UNITS['year2sec'],
             "hr": UNITS['hour2sec'], "day": UNITS['day2sec'], "month": UNITS['month2sec'], "year": UNITS['year2sec']}
KL_CONV = {"ft/s": UNITS['ft2cm'], "m/s": UNITS['m2cm'], "cm/s": UNITS['cm2cm'], "in/s": UNITS['in2cm'],
           "m/min": UNITS['m2cm'] / UNITS['min2sec'], "ft/min": UNITS['ft2cm'] / UNITS['min2sec'],
           "m/h": UNITS['m2cm'] / UNITS['hour2sec'], "m/hr": UNITS['m2cm'] / UNITS['hour2sec']}
DS_CONV = {"ft^2/s": UNITS['ft2cm']**2, "m^2/s": UNITS['m2cm']**2, "cm^2/s": UNITS['cm2cm'], "in^2/s": UNITS['in2cm']**2}
MASS_CONV = {"meq": 1, "meq/L": 1, "mg": 1, "ug": 1e-3, "ng": 1e-6, "mg/L": 1, "ug/L": 1e-3, "ng/L": 1e-6}

# Static vectors for UI choices
LENGTH_VECTOR = ["cm", "m", "mm", "in", "ft"]
VELOCITY_VECTOR = ["cm/s", "m/s", "m/min", "m/h", "in/s", "ft/s", "ft/min", "gpm/ft^2"]
TIME_VECTOR = ["hr", "day"]
FLOWRATE_VECTOR = ["cm^3/s", "m^3/s", "ft^3/s", "mL/s", "L/min", "mL/min", "gpm", "mgd"]
DIAMETER_VECTOR = ["cm", "m", "mm", "in", "ft"]
MODEL_VECTOR = ["Gel-Type (HSDM)", "Macroporous (PSDM)"]

NT_REPORT = 201  # Number of reporting steps

# helper functions

def _calculate_polynomial_derivatives(roots: np.ndarray) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    Calculates the first three derivatives of the Lagrange polynomials at the given roots.
    This helper function abstracts the logic common to both rad_colloc and ax_colloc.

    Args:
        roots: A 1D NumPy array of collocation points.

    Returns:
        A tuple containing three 1D NumPy arrays:
        - p1_derivs: Values related to the first derivative.
        - p2_derivs: Values related to the second derivative.
        - p3_derivs: Values related to the third derivative.
    """
    n_points = len(roots)
    p1_derivs = np.zeros(n_points)
    p2_derivs = np.zeros(n_points)
    p3_derivs = np.zeros(n_points)

    for i in range(n_points):
        x_i = roots[i]
        # Select all other roots
        j_values = np.delete(roots, i)
        delta = x_i - j_values

        # Initialize temporary arrays for the inner loop calculation
        p1 = np.zeros(n_points)
        p2 = np.zeros(n_points)
        p3 = np.zeros(n_points)
        p1[0] = 1.0

        # This loop calculates the derivatives for each root based on all other roots
        for j in range(n_points - 1):
            p1[j+1] = delta[j] * p1[j]
            p2[j+1] = delta[j] * p2[j] + 2 * p1[j]
            p3[j+1] = delta[j] * p3[j] + 3 * p2[j]

        p1_derivs[i] = p1[-1]
        p2_derivs[i] = p2[-1]
        p3_derivs[i] = p3[-1]

    return p1_derivs, p2_derivs, p3_derivs

def _calculate_first_derivative_matrix(roots: np.ndarray, p1_derivs: np.ndarray, p2_derivs: np.ndarray) -> np.ndarray:
    """
    Calculates the first derivative collocation matrix (A).
    This logic is identical for both the radial (Ar) and axial (AZ) cases.

    Args:
        roots: A 1D NumPy array of collocation points.
        p1_derivs: Values related to the first derivative from _calculate_polynomial_derivatives.
        p2_derivs: Values related to the second derivative from _calculate_polynomial_derivatives.

    Returns:
        A 2D NumPy array representing the first derivative matrix.
    """
    n_points = len(roots)
    # Create a matrix of root differences: diff[i, j] = roots[i] - roots[j]
    diff_matrix = roots.reshape(-1, 1) - roots

    # Create a boolean mask to identify the diagonal (where diff_matrix is 0)
    identity_mask = np.eye(n_points, dtype=bool)

    # Calculate off-diagonal elements using vectorized operations
    # This is equivalent to: p1[i] / (p1[j] * (roots[i] - roots[j]))
    A = np.divide(
        p1_derivs.reshape(-1, 1) / p1_derivs,
        diff_matrix,
        where=~identity_mask,
        out=np.zeros((n_points, n_points))
    )

    # Calculate and fill the diagonal elements
    diag_A = 0.5 * p2_derivs / p1_derivs
    np.fill_diagonal(A, diag_A)

    return A

# ==============================================================================
# Main Translated Functions
# ==============================================================================

def rad_colloc(N: int) -> tuple[np.ndarray, np.ndarray]:
    """
    Original R Code:
    rad_colloc <- function(N){
      # ... (full R code as provided in prompt) ...
      return(list(B, W))
    }

    Functional Explanation:
    This function translates the R `rad_colloc` function to Python. It calculates the
    collocation matrix 'B' for the 1-D radial Laplacian and the Gauss-Radau
    quadrature weights 'W' for a given number of collocation points N in a
    symmetric sphere.

    Key Translation Choices:
    - `jacobi.g.recurrences` and `polynomial.roots` from the R `orthopolynom` package
      are replaced by `scipy.special.sh_jacobi`, which directly computes the roots
      of shifted Jacobi polynomials on the interval [0, 1]. This is a more direct
      and standard approach in the Python scientific computing ecosystem.
    - R's `data.frame` is replaced with NumPy arrays, which are more performant and
      idiomatic for numerical computations in Python.
    - Matrix construction loops from R are vectorized using NumPy broadcasting. This
      is significantly more efficient and concise than element-wise loops.
    - The core logic for calculating the derivative values and the final matrices 'B'
      and weights 'W' remains identical to the original R code.
    """
    if N <= 1:
        raise ValueError("Number of collocation points N must be greater than 1.")
        
    # Number of interior collocation points
    N_int = N - 1

    # In R, the roots are calculated from Jacobi polynomial recurrence relations.
    # The Python equivalent finds the roots of the shifted Jacobi polynomial P_n^(2.5, 1.5)
    # directly, which is more efficient. The results are identical.
    # The R code uses rev() on roots; we use np.sort() for a canonical order.
    raw_roots = sh_jacobi(N_int, 2.5, 1.5).roots
    roots = np.concatenate((np.sort(raw_roots), [1.0]))
 
    # print(f"Collocation points: {roots}")

    # Calculate polynomial derivative values
    p1_derivs, p2_derivs, p3_derivs = _calculate_polynomial_derivatives(roots)

    # Calculate the first derivative matrix (Ar)
    Ar = _calculate_first_derivative_matrix(roots, p1_derivs, p2_derivs)

    # Calculate the second derivative matrix (Br) using vectorized operations
    identity_mask = np.eye(N, dtype=bool)
    diff_matrix = roots.reshape(-1, 1) - roots
    
    # Off-diagonal elements for Br
    off_diag_term = np.divide(1.0, diff_matrix, where=~identity_mask, out=np.zeros_like(diff_matrix))
    Br = 2 * Ar * (np.diag(Ar).reshape(-1, 1) - off_diag_term)
    
    # Diagonal elements for Br
    diag_Br = (1./3.) * p3_derivs / p1_derivs
    np.fill_diagonal(Br, diag_Br)

    # Calculate the symmetric equivalent matrices, same as in R
    Br_sym = 4 * roots.reshape(-1, 1) * Br + 6 * Ar

    # Calculate quadrature weights (W), same as in R
    a_weight = 2.0
    w_i_prime = 1.0 / (roots * p1_derivs**2)
    W = (1.0 / (a_weight + 1.0)) * w_i_prime / np.sum(w_i_prime)

    # The R function returns a list(B, W). Python returns a tuple.
    return Br_sym, W


def ax_colloc(NZ: int) -> np.ndarray:
    """
    Original R Code:
    ax_colloc <- function(NZ) {
      # ... (full R code as provided in prompt) ...
      return(AZ)
    }

    Functional Explanation:
    This function translates the R `ax_colloc` function. It computes the axial
    discretization matrix 'AZ' using shifted Legendre polynomials for a given
    number of points NZ.

    Key Translation Choices:
    - As with `rad_colloc_py`, `scipy.special.sh_jacobi` is used for finding roots.
      For shifted Legendre polynomials, the parameters are (1.0, 1.0).
    - The R code constructs the roots as `c(0, rev(...), 1)`. The Python equivalent
      is `np.concatenate(([0.0], np.sort(...), [1.0]))`.
    - The core logic for calculating the first derivative matrix 'AZ' is identical
      to the `Ar` calculation in `rad_colloc`, so it has been refactored into the
      `_calculate_first_derivative_matrix` helper function to avoid code duplication.
    """
    if NZ <= 2:
        raise ValueError("Number of collocation points NZ must be greater than 2.")
        
    # Number of interior points

    NZ_int = NZ - 2

    # Get roots of the shifted Legendre polynomial (Jacobi with alpha=1.0, beta=1.0)
    raw_roots = sh_jacobi(NZ_int, 1.0, 1.0).roots
    roots = np.concatenate(([0.0], np.sort(raw_roots), [1.0]))

    # Calculate polynomial derivative values needed for the matrix
    p1_derivs, p2_derivs, _ = _calculate_polynomial_derivatives(roots)

    # Calculate the first derivative matrix (AZ)
    AZ = _calculate_first_derivative_matrix(roots, p1_derivs, p2_derivs)

    return AZ
# =============================================================================
# Original R Code: HSDMIX_solve and PSDMIX_solve functions
#
# HSDMIX_solve <- function (params, ions, Cin, inputtime, nt_report){...}
#
# Explanation of Python translation:
# This is the core solver for the Homogeneous Surface Diffusion Model (HSDM).
# - The function signature is kept similar, taking pandas DataFrames as input.
# - R's `filter` is replaced by pandas boolean indexing.
# - `approxfun` is replaced by `scipy.interpolate.interp1d`.
# - State vector `x0` is initialized as a NumPy array. R's `dim(x) <- ...` is
#   replaced with `np.reshape`.
# - The `diffun` (derivative function) is the most critical part.
#   - It's defined as a nested function to have access to the solver's scope.
#   - All array indexing is converted from 1-based to 0-based.
#     e.g., R `C[, 2:NZ]` -> Python `C[:, 1:NZ]`.
#   - R's matrix multiplication `%*%` -> Python's `@`.
#   - `colSums` -> `np.sum(axis=0)`.
#   - `aperm` -> `np.transpose`.
#   - The logic for divalent and monovalent isotherms is carefully preserved.
# - `deSolve::ode(method="lsode")` is replaced by `scipy.integrate.solve_ivp(method="LSODA")`.
#   `solve_ivp` requires `t_span` (start, end) and `t_eval` (points to report),
#   which is analogous to R's `times` argument. The state vector `y` must be 1D.
# - The output is processed to match the structure returned by the R function.
# - `PSDMIX_solve` follows the same translation pattern for the Pore and Surface
#   Diffusion Model (PSDM), with the additional `Dp` parameter and complexity
#   in the `diffun`.
# =============================================================================
def HSDMIX_solve(params, ions, Cin, inputtime, nt_report):
    
    # print('HSDMix inputs', params, ions, Cin, inputtime, nt_report)
    """Solves the Homogeneous Surface Diffusion Model (HSDM)."""
    # Extract parameters
    NR = int(params.loc[params['name'] == 'nr', 'value'].iloc[0])
    NZ = int(params.loc[params['name'] == 'nz', 'value'].iloc[0])
    Q = params.loc[params['name'] == 'Q', 'value'].iloc[0]
    L = params.loc[params['name'] == 'L', 'value'].iloc[0]
    v = params.loc[params['name'] == 'v', 'value'].iloc[0]
    EBED = params.loc[params['name'] == 'EBED', 'value'].iloc[0]
    rb = params.loc[params['name'] == 'rb', 'value'].iloc[0]

    # Ion info
    ion_names = ions['name'].tolist()
    KxA = ions['KxA'].to_numpy()
    valence = ions['valence'].to_numpy()
    kL = ions['kL'].to_numpy()
    Ds = ions['Ds'].to_numpy()

    C_in_t = Cin.copy().to_numpy()
    NION = len(ion_names)

    # Derived parameters
    C_in_t[:, 0] *= inputtime # Convert time to seconds
    t_max = C_in_t[-1, 0]
    times = np.linspace(0.0, t_max * 0.99, nt_report)

    C_in_0 = C_in_t[0, 1:(NION + 1)]
    CT = np.sum(C_in_0)
    NEQ = (NR + 1) * NION * NZ

    # Interpolating functions for influent concentrations
    interp_list = [interp1d(C_in_t[:, 0], C_in_t[:, i + 1], bounds_error=False, fill_value="extrapolate") for i in range(NION)]
  
    # Initialize grid
    x0 = np.zeros(((NR + 1), NION, NZ))
    x0[-1, :, 0] = C_in_0  # Inlet liquid concentrations
    x0[-1, 0, 1:] = CT     # Rest of liquid is presaturant
    x0[0:NR, 0, :] = Q     # Resin initially loaded with presaturant
    x0 = x0.flatten()


    # Collocation matrices
    BR, WR = rad_colloc(NR)
    AZ = ax_colloc(NZ)
    
    # print(BR)
    # print(WR)
    # print(AZ)
    

    def diffun(t, y):
        x = y.reshape((NR + 1, NION, NZ))
        C = x[-1, :, :]  # Liquid phase concentrations
        q = x[0:NR, :, :]  # Solid phase concentrations

        dx_dt = np.zeros_like(x)

        # Update influent concentrations at current time t
        C_t = np.array([interp(t) for interp in interp_list])
        dx_dt[-1, :, 0] = 0 # Inlet concentration is boundary condition, not a state
        C[:, 0] = C_t

        # Advection
        # R: t(AZ %*% t(C)) -> Python: (AZ @ C.T).T
        AZ_C = (AZ @ C.T).T
        
        # Calculate surface flux J
        qs = q[NR - 1, :, :]
        CT_test = np.sum(C, axis=0)

        C_star = np.zeros((NION, NZ))
        J = np.zeros((NION, NZ))

        # --- Isotherm Calculation (vectorized) ---
        z_slice = slice(1, NZ)
        
        is_divalent = np.any(valence == 2)
        if is_divalent:
            dv_ions_mask = valence == 2
            mv_ions_mask = valence == 1
            mv_ions_mask[0] = False # Exclude presaturant
            
            qs_1 = qs[0, z_slice]
            # Add a small epsilon to avoid division by zero
            qs_1[qs_1 == 0] = 1e-9

            cc = -CT_test[z_slice]
            bb = 1 + np.sum(qs[mv_ions_mask, z_slice] / KxA[mv_ions_mask, np.newaxis], axis=0) / qs_1
            aa = np.sum(qs[dv_ions_mask, z_slice] / KxA[dv_ions_mask, np.newaxis], axis=0) / qs_1**2
            
            denom = -bb - np.sqrt(bb**2 - 4 * aa * cc)
            denom[denom == 0] = 1e-9 # Avoid division by zero
            C_star[0, z_slice] = 2 * (cc / denom)

            # Calculate other C_star based on C_star of reference ion
            for i in range(1, NION):
                C_star[i, z_slice] = (qs[i, z_slice] / KxA[i]) * (C_star[0, z_slice] / qs_1)**valence[i]

        else: # Monovalent only
            sum_terms = np.sum(qs[:, z_slice] / KxA[:, np.newaxis], axis=0) / CT_test[z_slice]
            for i in range(1, NION):
                C_star[i, z_slice] = qs[i, z_slice] / KxA[i] / sum_terms

        # Surface flux J
        J[1:, z_slice] = -kL[1:, np.newaxis] * (C[1:, z_slice] - C_star[1:, z_slice])
        J[0, z_slice] = -np.sum(J[1:, z_slice], axis=0) # Reference ion
        Jas = (3 / rb) * J

        # Liquid phase mass balance
        dx_dt[-1, :, z_slice] = (-v / L * AZ_C[:, z_slice] + (1 - EBED) * Jas[:, z_slice]) / EBED

        # Solid phase mass balance
        # Internal diffusion
        # R: BR %*% q[, ii, 2:NZ] -> Python: BR @ q[:, ii, 1:NZ]
        BR_q = np.zeros_like(q)
        for ii in range(NION):
            BR_q[:, ii, z_slice] = BR @ q[:, ii, z_slice]

        dq_dt = np.zeros_like(q)
        # dq_dt[:, 1:, :] = (Ds[1:, np.newaxis, np.newaxis] / rb**2) * BR_q[:, 1:, :]
        
        ds_term_reshaped = Ds[1:][np.newaxis, :, np.newaxis] / (rb**2)
        dq_dt[:, 1:, :] = ds_term_reshaped * BR_q[:, 1:, :]
        
        # Sum of fluxes for reference ion
        # R: -colSums(aperm(dq_dt, c(2,1,3))[2:NION, 1:(NR-1), 2:NZ])
        sum_dq_dt = -np.sum(dq_dt[0:NR-1, 1:, z_slice], axis=1)
        dq_dt[0:NR-1, 0, z_slice] = sum_dq_dt

        # Surface boundary condition for solid phase
        # R: WR[1:(NR-1)] %*% dq_dt[1:(NR-1), ii, 2:NZ]
        # surf_term = WR[0:NR-1] @ dq_dt[0:NR-1, :, z_slice]
        surf_term = np.tensordot(WR[0:NR-1], dq_dt[0:NR-1, :, z_slice], axes=([0], [0]))

        dx_dt[0:NR-1, :, z_slice] = dq_dt[0:NR-1, :, z_slice]
        dx_dt[NR-1, :, z_slice] = (-1 / rb * J[:, z_slice] - surf_term) / WR[NR-1]

        # Inlet is a boundary condition, its state doesn't change via ODE
        dx_dt[:, :, 0] = 0.0

        return dx_dt.flatten()

    # print(x0,'\n',times )
    # Integration
    sol = solve_ivp(diffun, [times[0], times[-1]], x0, t_eval=times,
                    method='BDF' )


    if sol.success:
        t_out = sol.t / 3600  # seconds to hours
        x_out = sol.y.T.reshape(nt_report, NR + 1, NION, NZ)
        # Final check for charge balance (optional, for robustness)
        # Simplified check here
        print('HSDMix_Solve success')
        return t_out, x_out
    else:
        print('HSDMix_Solve failed')
        # Return empty results on failure
        return times / 3600, np.zeros((nt_report, NR + 1, NION, NZ))


def PSDMIX_solve(params, ions, Cin, inputtime, nt_report):
    """Solves the Pore and Surface Diffusion Model (PSDM)."""
    # Extract parameters
    NR = int(params.loc[params['name'] == 'nr', 'value'].iloc[0])
    NZ = int(params.loc[params['name'] == 'nz', 'value'].iloc[0])
    Q = params.loc[params['name'] == 'Q', 'value'].iloc[0]
    L = params.loc[params['name'] == 'L', 'value'].iloc[0]
    v = params.loc[params['name'] == 'v', 'value'].iloc[0]
    EBED = params.loc[params['name'] == 'EBED', 'value'].iloc[0]
    EPOR = params.loc[params['name'] == 'EPOR', 'value'].iloc[0]
    rb = params.loc[params['name'] == 'rb', 'value'].iloc[0]

    # Ion info
    ion_names = ions['name'].tolist()
    KxA = ions['KxA'].to_numpy()
    valence = ions['valence'].to_numpy()
    kL = ions['kL'].to_numpy()
    Ds = ions['Ds'].to_numpy()
    Dp = ions['Dp'].to_numpy()
    
    C_in_t = Cin.copy().to_numpy()
    NION = len(ion_names)

    # Derived parameters
    C_in_t[:, 0] *= inputtime # Convert time to seconds
    t_max = C_in_t[-1, 0]
    times = np.linspace(0.0, t_max * 0.99, nt_report)

    C_in_0 = C_in_t[0, 1:(NION + 1)]
    CT = np.sum(C_in_0)
    NEQ = (NR + 1) * NION * NZ

    # Interpolating functions
    interp_list = [interp1d(C_in_t[:, 0], C_in_t[:, i + 1], bounds_error=False, fill_value="extrapolate") for i in range(NION)]

    # Initialize grid
    x0 = np.zeros(((NR + 1), NION, NZ))
    x0[-1, :, 0] = C_in_0
    x0[-1, 0, 1:] = CT
    x0[0:NR, 0, :] = Q
    x0 = x0.flatten()

    # Collocation
    BR, WR = rad_colloc(NR)
    AZ = ax_colloc(NZ)
    
    def diffun(t, y):
        x = y.reshape((NR + 1, NION, NZ))
        C = x[-1, :, :]
        Y = x[0:NR, :, :]
        q = Y / (1 - EPOR)
        
        dx_dt = np.zeros_like(x)

        # Update influent
        C_t = np.array([interp(t) for interp in interp_list])
        dx_dt[-1, :, 0] = 0
        C[:, 0] = C_t

        # Advection
        AZ_C = (AZ @ C.T).T
        
        # Isotherm in the pore liquid
        CT_test = np.sum(C, axis=0)
        Cpore = np.zeros_like(q)
        z_slice = slice(1, NZ)

        is_divalent = np.any(valence == 2)
        if is_divalent:
            dv_ions_mask = valence == 2
            mv_ions_mask = valence == 1
            mv_ions_mask[0] = False
            
            for jj in range(NR):
                q_jj = q[jj, :, z_slice]
                q_jj_1 = q_jj[0, :]
                q_jj_1[q_jj_1 == 0] = 1e-9
                
                cc = -CT_test[z_slice]
                bb = 1 + np.sum(q_jj[mv_ions_mask, :] / KxA[mv_ions_mask, np.newaxis], axis=0) / q_jj_1
                aa = np.sum(q_jj[dv_ions_mask, :] / KxA[dv_ions_mask, np.newaxis], axis=0) / q_jj_1**2

                denom = -bb - np.sqrt(bb**2 - 4 * aa * cc)
                denom[denom == 0] = 1e-9
                Cpore[jj, 0, z_slice] = 2 * (cc / denom)

                for i in range(1, NION):
                     Cpore[jj, i, z_slice] = (q_jj[i,:] / KxA[i]) * (Cpore[jj, 0, z_slice] / q_jj_1)**valence[i]
        else: # Monovalent
             for jj in range(NR):
                q_jj = q[jj, :, z_slice]
                sum_terms = np.sum(q_jj / KxA[:, np.newaxis], axis=0) / CT_test[z_slice]
                for i in range(1, NION):
                    Cpore[jj, i, z_slice] = q_jj[i, :] / KxA[i] / sum_terms
        
        C_star = Cpore[NR - 1, :, :]
        J = np.zeros((NION, NZ))
        J[1:, z_slice] = -kL[1:, np.newaxis] * (C[1:, z_slice] - C_star[1:, z_slice])
        J[0, z_slice] = -np.sum(J[1:, z_slice], axis=0)
        Jas = (3 / rb) * J

        # Liquid phase
        dx_dt[-1, :, z_slice] = (-v / L * AZ_C[:, z_slice] + (1 - EBED) * Jas[:, z_slice]) / EBED

        # Solid phase
        BR_Y = np.zeros_like(Y)
        BR_Cpore = np.zeros_like(Cpore)
        for ii in range(NION):
            BR_Y[:, ii, z_slice] = BR @ Y[:, ii, z_slice]
            BR_Cpore[:, ii, z_slice] = BR @ Cpore[:, ii, z_slice]
        

        dY_dt = np.zeros_like(Y)
        # dY_dt_calc = (EPOR * (Dp[1:] - Ds[1:])[:, np.newaxis, np.newaxis] * BR_Cpore[:, 1:, :] + Ds[1:, np.newaxis, np.newaxis] * BR_Y[:, 1:, :]) / rb**2
        dY_dt_calc = (EPOR * (Dp[1:] - Ds[1:])[ np.newaxis,:, np.newaxis] * BR_Cpore[:, 1:, :] + Ds[np.newaxis,1:,  np.newaxis] * BR_Y[:, 1:, :]) / rb**2
        
        dY_dt[:, 1:, :] = dY_dt_calc
        
        sum_dY_dt = -np.sum(dY_dt[0:NR-1, 1:, z_slice], axis=1)
        dY_dt[0:NR-1, 0, z_slice] = sum_dY_dt
        
        # surf_term = WR[0:NR-1] @ dY_dt[0:NR-1, :, z_slice]
        surf_term = np.tensordot(WR[0:NR-1], dY_dt[0:NR-1, :, z_slice], axes=([0], [0]))
        
        dx_dt[0:NR-1, :, z_slice] = dY_dt[0:NR-1, :, z_slice]
        dx_dt[NR-1, :, z_slice] = (-1 / rb * J[:, z_slice] - surf_term) / WR[NR-1]
        
        dx_dt[:, :, 0] = 0.0

        return dx_dt.flatten()

    sol = solve_ivp(diffun, [times[0], times[-1]], x0, t_eval=times, method='LSODA')

    if sol.success:
        t_out = sol.t / 3600
        x_out = sol.y.T.reshape(nt_report, NR + 1, NION, NZ)
        return t_out, x_out
    else:
        return times / 3600, np.zeros((nt_report, NR + 1, NION, NZ))


# =============================================================================
# Python Helper Functions
# These functions replace R data manipulation and preparation logic.
# - cin_correct: Converts influent concentrations to meq/L. Replaces R version.
# - model_prep: Prepares inputs and calls the correct solver. Replaces R version.
# - create_plotly: Generates plots using Python's Plotly library.
# =============================================================================
def cin_correct(ions_df, cin_df):
    """Converts concentration units in the Cin DataFrame to meq/L."""
    corr_cin = cin_df.copy()
    for _, row in ions_df.iterrows():
        mass_units = row.get("conc_units", "meq")
        if mass_units not in ['meq', 'meq/L']:
            mw = row["mw"]
            valence = row["valence"]
            mass_mult = MASS_CONV.get(mass_units, 1.0) / mw * valence
            compound = row["name"]
            if compound in corr_cin.columns:
                corr_cin[compound] *= mass_mult
    return corr_cin

def mass_converter_to_mgl(ions_df, concs_df):
    """Converts meq/L concentrations in the dataframe to mg/L."""
    corr_df = concs_df.copy()
    for _, row in ions_df.iterrows():
        mass_units = row.get("conc_units", "meq")
        compound = row["name"]
        if compound in corr_df.columns:
            if mass_units in ['meq', 'meq/L']:
                 mass_mult = row["mw"] / row["valence"]
                 corr_df[compound] *= mass_mult
            else: # Already in mass/L, just convert to mg/L
                 mass_mult = MASS_CONV.get(mass_units, 1.0)
                 corr_df[compound] *= mass_mult
    return corr_df


def model_prep(inputs, iondata, concdata, nt_report):
    """Prepares parameters and calls the appropriate solver."""
    if inputs['veloselect']() == 'Linear':
        Vv = inputs['Vv']() * VELOCITY_CONV[inputs['VelocityUnits']()]
    else:
        Dv_cm = inputs['Dv']() * LENGTH_CONV[inputs['DiameterUnits']()]
        area = np.pi / 4 * (Dv_cm ** 2)
        Fv_cm3ps = inputs['Fv']() * VOLUMETRIC_CONV[inputs['FlowrateUnits']()]
        Vv = Fv_cm3ps / area

    param_dict = {
        "Q": ("meq/L", inputs['Qv']()),
        "EBED": (None, inputs['EBEDv']()),
        "L": ("cm", inputs['Lv']() * LENGTH_CONV[inputs['LengthUnits']()]),
        "v": ("cm/s", Vv),
        "rb": ("cm", inputs['rbv']() * LENGTH_CONV[inputs['rbunits']()]),
        "nr": (None, inputs['nrv']()),
        "nz": (None, inputs['nzv']()),
        "time": (inputs['timeunits2'](), 1)
    }
    if inputs['model']() == "Macroporous (PSDM)":
        param_dict["EPOR"] = (None, inputs['EPORv']())

    paramdataframe = pd.DataFrame([
        {'name': k, 'units': v[0], 'value': v[1]} for k, v in param_dict.items()
    ])

    # Check for column name consistency
    ion_names = set(iondata['name'])
    cin_names = set(c for c in concdata.columns if c != 'time')
    if not ion_names.issubset(cin_names) or not cin_names.issubset(ion_names):
        print("Warning: Mismatch between ion names in 'ions' and 'Cin' sheets.")
        # Simplified error handling compared to R version's 'error' counter
        return None

    corr_ions = iondata.copy()
    corr_cin = cin_correct(iondata, concdata)

    # Convert kL and Ds/Dp units
    for i, row in iondata.iterrows():
        corr_ions.loc[i, 'kL'] = row['kL'] * KL_CONV[row['kL_units']]
        corr_ions.loc[i, 'Ds'] = row['Ds'] * DS_CONV[row['Ds_units']]
        if inputs['model']() == "Macroporous (PSDM)" and 'Dp' in row:
            corr_ions.loc[i, 'Dp'] = row['Dp'] * DS_CONV[row['Dp_units']]

    timeconverter = TIME_CONV[inputs['timeunits2']()]

    if inputs['model']() == "Gel-Type (HSDM)":
        return HSDMIX_solve(paramdataframe, corr_ions, corr_cin, timeconverter, nt_report)
    elif inputs['model']() == "Macroporous (PSDM)":
        return PSDMIX_solve(paramdataframe, corr_ions, corr_cin, timeconverter, nt_report)
    return None

def create_plotly(computed_df, effluent_df, influent_df, title, y_axis_title, x_axis_title):
    """Creates a plotly figure from computed, effluent, and influent data."""
    import plotly.graph_objects as go

    fig = go.Figure()
    
    # Computed data (lines)
    if computed_df is not None and not computed_df.empty:
        for i, name in enumerate(computed_df['name'].unique()):
            df_sub = computed_df[computed_df['name'] == name]
            fig.add_trace(go.Scatter(
                x=df_sub['hours'], y=df_sub['conc'],
                mode='lines', name=name,
                line=dict(color=STEPPED_SEQUENTIAL_5_STEPS[i % len(STEPPED_SEQUENTIAL_5_STEPS)])
            ))

    # Effluent data (markers)
    if effluent_df is not None and not effluent_df.empty:
        for i, name in enumerate(effluent_df['name'].unique()):
             df_sub = effluent_df[effluent_df['name'] == name]
             # Match color with computed data
             color_name = name.replace('_effluent', '')
             try:
                 color_idx = computed_df['name'].unique().tolist().index(color_name)
                 color = STEPPED_SEQUENTIAL_5_STEPS[color_idx % len(STEPPED_SEQUENTIAL_5_STEPS)]
             except (ValueError, AttributeError):
                 color = 'black' # Default color if not found
             
             fig.add_trace(go.Scatter(
                x=df_sub['hours'], y=df_sub['conc'],
                mode='markers', name=name,
                marker=dict(color=color)
            ))
            
    # Influent data (lines+markers)
    if influent_df is not None and not influent_df.empty:
        for i, name in enumerate(influent_df['name'].unique()):
            df_sub = influent_df[influent_df['name'] == name]
            # Match color
            color_name = name.replace('_influent', '')
            try:
                 color_idx = computed_df['name'].unique().tolist().index(color_name)
                 color = STEPPED_SEQUENTIAL_5_STEPS[color_idx % len(STEPPED_SEQUENTIAL_5_STEPS)]
            except (ValueError, AttributeError):
                 color = 'grey'
                 
            fig.add_trace(go.Scatter(
                x=df_sub['hours'], y=df_sub['conc'],
                mode='lines+markers', name=name,
                line=dict(color=color, dash='dot')
            ))
            
    fig.update_layout(
        title=title,
        xaxis_title=x_axis_title,
        yaxis_title=y_axis_title,
        hovermode='x unified',
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
    )
    return fig


# =============================================================================
# Shiny UI Definition
# =============================================================================
# The R UI is translated to Python using shiny.ui.
# - `fluidPage` -> `ui.page_fluid`
# - `navbarPage` -> `ui.page_navbar`
# - `sidebarLayout` with `sidebarPanel` and `mainPanel` is a standard structure.
# - `*Input` functions are mapped directly (e.g., `selectInput` -> `ui.input_select`).
# - The R `DataEditR` is not available in Python. This is replaced with a
#   `ui.output_data_frame` to display the data. The user is expected to edit
#   data via the input Excel file, which aligns with the app's workflow.
# - The custom EPA header HTML is included using `ui.HTML`.
# =============================================================================
app_ui = ui.page_fluid(
    ui.HTML("""
    <header class='masthead clearfix' role='banner'>
     <img alt='' class='site-logo' src='https://www.epa.gov/sites/all/themes/epa/logo.png'>
     <div class='site-name-and-slogan'>
     <h1 class='site-name'><a href='https://www.epa.gov' rel='home' title='Go to the home page'><span>US EPA</span></a></h1>
     <div class='site-slogan'>United States Environmental Protection Agency</div>
     </div>
    </header>
    <div class='main-column clearfix'><h1 class='page-title'>Ion Exchange Model (Python Version)</h1></div>
    """),
    # shinyswatch.theme.cerulean(),
    ui.page_navbar(
        ui.nav_panel("Input",
            ui.layout_sidebar(
                ui.sidebar(
                    ui.input_select("model", "Model Selection", choices=MODEL_VECTOR),
                    ui.input_file("file1", "Choose .xlsx File", accept=".xlsx"),
                    ui.output_text("selected_file_text"),
                    ui.hr(),
                    ui.input_slider("nrv", "Radial Collocation Points", min=3, max=18, value=7),
                    ui.input_slider("nzv", "Axial Collocation Points", min=3, max=18, value=13),
                    ui.hr(),
                    ui.input_action_button("run_button", "Run Analysis", class_="btn-primary"),
                ),
                ui.navset_card_tab(
                    ui.nav_panel("Column Parameters",
                        ui.h4(ui.strong("Resin Characteristics")),
                        ui.row(ui.column(4, ui.input_numeric("Qv", "Resin Capacity (meq/L)", 1400)),
                               ui.column(4, ui.input_numeric("rbv", "Bead Radius", 0.03375)),
                               ui.column(4, ui.input_select("rbunits", "Units", ["cm", "m", "mm", "in", "ft"]))),
                        ui.row(ui.column(4, ui.input_numeric("EBEDv", "Bed Porosity", 0.35)),
                               ui.column(4, ui.input_numeric("EPORv", "Bead Porosity (PSDM)", 0.2))),
                        ui.hr(),
                        ui.h4(ui.strong("Column Specifications")),
                        ui.input_radio_buttons("veloselect", "Flow Specification", ["Linear", "Volumetric"], selected="Linear", inline=True),
                        ui.row(ui.column(4, ui.input_numeric("Lv", "Length", 14.765)),
                               ui.column(4, ui.input_select("LengthUnits", "Units", ["cm", "m", "mm", "in", "ft"]))),
                        ui.row(ui.column(4, ui.input_numeric("Vv", "Velocity", 0.123)),
                               ui.column(4, ui.input_select("VelocityUnits", "Units", list(VELOCITY_CONV.keys())))),
                        ui.row(ui.column(4, ui.input_numeric("Dv", "Diameter", 4.0)),
                               ui.column(4, ui.input_select("DiameterUnits", "Units", ["cm", "m", "in", "ft"]))),
                        ui.row(ui.column(4, ui.input_numeric("Fv", "Flow Rate", 1.546)),
                               ui.column(4, ui.input_select("FlowrateUnits", "Units", list(VOLUMETRIC_CONV.keys())))),
                        ui.hr(),
                        ui.h4(ui.strong("Concentration Time")),
                        ui.row(ui.column(4, ui.input_select("timeunits2", "Units", ["hr", "day"]))),
                    ),
                    ui.nav_panel("Ions & Concentrations",
                        ui.h4("Ion List"), ui.output_data_frame("ion_table"),
                        ui.h4("Influent Concentration Points"), ui.output_data_frame("cin_table"),
                        ui.h4("Effluent Concentration Points"), ui.output_data_frame("effluent_table"),
                    ),
                    ui.nav_panel("Alkalinity",
                        ui.h4("Bicarbonate Concentration of Alkalinity"),
                        ui.p("This calculator can be used to find bicarbonate concentrations from pH measurements."),
                        ui.hr(),
                        ui.row(
                            ui.column(4, ui.input_numeric("alkvalue", "Alkalinity Value", 100)),
                            ui.column(4, ui.input_select("alkunits", "Concentration Units", ["mg/L CaCO3"])),
                        ),
                        ui.row(
                            ui.column(8, ui.input_slider("pH", "pH", min=6, max=11,value= 7, step =0.1)),
                        ),
                        ui.hr(),
                        ui.h5("Bicarbonate Concentration (meq/L)"), ui.output_text("bicarb_meq_L"),
                        ui.h5("Bicarbonate Concentration (mg C/L)"), ui.output_text("bicarb_mg_C_L"),
                        ui.h5("Bicarbonate Concentration (mg HCO3-/L)"), ui.output_text("bicarb_mg_HCO3_L"),
                    ),
                    ui.nav_panel("kL Guesser",
                        ui.h4("Film Transfer Coefficient (kL) Estimator"),
                        ui.p("Estimate kL values for common PFAS compounds using the Gnielinski equation."),
                        ui.hr(),
                        ui.row(
                            ui.column(4, ui.input_numeric("temp", "Temperature", 23)),
                            ui.column(4, ui.input_select("tempunits", "Units", ["deg C"])),
                        ),
                        ui.input_action_button('estimate_kl', 'Estimate Values', class_="btn-info"),
                        ui.hr(),
                        ui.row(
                            ui.column(6, ui.h5("PFAS Properties"), ui.output_data_frame("pfas_properties_table")),
                            ui.column(6, ui.h5("kL Estimates"), ui.output_data_frame("kl_estimates_table")),
                        ),
                    )
                )
            )
        ),
        ui.nav_panel("Output",
            ui.layout_sidebar(
                ui.sidebar(
                    ui.input_select("OCunits", "Output Concentration Units", choices=["mg/L", "ug/L", "ng/L", "c/c0"]),
                    ui.input_select("timeunits", "Output Time Units", choices=["Hours", "Days", "Bed Volumes (x1000)", "Months", "Years"]),
                    ui.hr(),
                    ui.input_checkbox("computeddata", "Show Computed Data", value=True),
                    ui.input_checkbox("effluentdata", "Show Effluent Data", value=False),
                    ui.input_checkbox("influentdata", "Show Influent Data", value=False),
                    ui.hr(),
                    ui.download_button("save_button", "Save Data", class_="btn-success"),
                ),
                ui.panel_absolute(
                    output_widget("plot_counterions"),
                    ui.hr(),
                    output_widget("plot_other_ions"),
                )
            )
        ),
        ui.nav_panel("About",
            ui.h5("About the Ion Exchange Model"),
            ui.p("The Ion Exchange Model is a tool used to model a strong-base anion exchange unit operation in a drinking water treatment plant... This is a Python translation of the original R model."),
            ui.h5("Developed By"),
            ui.p("Original R Model: David Colantonio, Levi Haupert, Jonathan Burkhardt, Cole Sandlin"),
            ui.p("")
        ),
        title="Ion Exchange Model",
    )
)

# =============================================================================
# Shiny Server Logic
# =============================================================================
def server(input, output, session):
    # Reactive values to store data from the uploaded file
    app_data = reactive.Value({})
    pfas_properties = reactive.Value(pd.DataFrame())

    @reactive.Effect
    def _():
        # Load default config file
        default_file = Path(__file__).parent / "IEX_config.xlsx"
        if default_file.exists(): process_file(str(default_file))
        # Load PFAS properties for kL Guesser
        pfas_file = Path(__file__).parent / "PSDM" / "PFAS_properties.xlsx"
        if pfas_file.exists():
            df = pd.read_excel(pfas_file, index_col=0).T
            df.columns = df.iloc[0]
            df = df.iloc[1:]
            df = df[['MolarVol']].rename(columns={'MolarVol': 'MolarVol (cm^3/mol)'})
            pfas_properties.set(df)

    @reactive.Effect
    @reactive.event(input.file1)
    def _():
        f = input.file1()
        if f: process_file(f[0]["datapath"])

    def process_file(filepath):
        try:
            params = pd.read_excel(filepath, sheet_name="params")
            ions = pd.read_excel(filepath, sheet_name="ions")
            cin = pd.read_excel(filepath, sheet_name="Cin")
            cin.columns = [c.lower() if c.lower() == 'time' else c for c in cin.columns]
            
            # Effluent might not exist, handle gracefully
            try:
                effluent = pd.read_excel(filepath, sheet_name="effluent")
            except Exception:
                effluent = pd.DataFrame({'time': [0], 'CHLORIDE': [0]})

            app_data.set({
                "params": params, "ions": ions, "cin": cin, "effluent": effluent,
                "filename": os.path.basename(filepath)
            })
            ui.notification_show("File processed successfully.", duration=5, type="message")
        except Exception as e:
            ui.notification_show(f"Error reading Excel file: {e}", duration=10, type="error")

    # Update UI controls from loaded file data
    @reactive.Effect
    def _():
        data = app_data()
        if "params" in data:
            params = data["params"]
            
            def get_param(name, default):
                val = params[params['name'] == name]['value']
                return val.iloc[0] if not val.empty else default

            def get_unit(name, default):
                unit = params[params['name'] == name]['units']
                return unit.iloc[0] if not unit.empty else default
            
            # Update numeric inputs
            ui.update_numeric("Qv", value=get_param('Q', 1400))
            ui.update_numeric("rbv", value=get_param('rb', 0.03375))
            ui.update_numeric("EBEDv", value=get_param('EBED', 0.35))
            ui.update_numeric("EPORv", value=get_param('EPOR', 0.2))
            ui.update_numeric("Lv", value=get_param('L', 14.765))
            ui.update_numeric("nrv", value=get_param('nr', 7))
            ui.update_numeric("nzv", value=get_param('nz', 13))

            # Update velocity/flow
            if 'v' in params['name'].values:
                ui.update_radio_buttons("veloselect", selected="Linear")
                ui.update_numeric("Vv", value=get_param('v', 0.123))
                ui.update_select("VelocityUnits", selected=get_unit('v', 'cm/s'))
            elif 'flrt' in params['name'].values and 'diam' in params['name'].values:
                ui.update_radio_buttons("veloselect", selected="Volumetric")
                ui.update_numeric("Fv", value=get_param('flrt', 1.546))
                ui.update_select("FlowrateUnits", selected=get_unit('flrt', 'L/min'))
                ui.update_numeric("Dv", value=get_param('diam', 4.0))
                ui.update_select("DiameterUnits", selected=get_unit('diam', 'cm'))

    @output
    @render.text
    def selected_file_text():
        data = app_data()
        return f"Loaded: {data.get('filename', 'No file loaded')}"

    # Display data tables
    @output
    @render.data_frame
    def ion_table():
        return app_data().get("ions", pd.DataFrame())

    @output
    @render.data_frame
    def cin_table():
        return app_data().get("cin", pd.DataFrame())
        
    @output
    @render.data_frame
    def effluent_table():
        return app_data().get("effluent", pd.DataFrame())

    # Run the model
    @reactive.Calc
    @reactive.event(input.run_button)
    def model_results():
        data = app_data()
        req("ions" in data, "cin" in data)

        with ui.Progress(min=1, max=15) as p:
            p.set(message="Model calculation in progress", detail="This may take a moment...")
            
            # Create a dict of all UI inputs for model_prep
            ui_inputs = {key: reactive.Value(getattr(input, key)()) for key in dir(input) if not key.startswith('_')}
            
            results = model_prep(ui_inputs, data["ions"], data["cin"], NT_REPORT)
            if results is None:
                ui.notification_show("Model run failed.", type="error")
                return None
            
            ui.notification_show("Model run complete.", type="message")
            return results
    # --- Alkalinity Tab Logic ---
    @reactive.Calc
    def bicarbonate_calcs():
        K1, K2, KW = 10**-6.352, 10**-10.329, 10**-14
        h_plus = 10**-input.pH()
        oh_minus = KW / h_plus
        alpha_1 = 1 / (1 + h_plus / K1 + K2 / h_plus)
        alpha_2 = 1 / (1 + h_plus / K2 + h_plus**2 / (K1 * K2))
        tot_co3_M = (input.alkvalue() / 50000 + h_plus - oh_minus) / (alpha_1 + 2 * alpha_2)
        hco3_mM_L = alpha_1 * tot_co3_M * 1000
        if hco3_mM_L < 0: return "INVALID", "INVALID", "INVALID"
        return f"{hco3_mM_L:.4f}", f"{hco3_mM_L * 12:.4f}", f"{hco3_mM_L * 61:.4f}"

    @output
    @render.text
    def bicarb_meq_L(): return bicarbonate_calcs()[0]
    @output
    @render.text
    def bicarb_mg_C_L(): return bicarbonate_calcs()[1]
    @output
    @render.text
    def bicarb_mg_HCO3_L(): return bicarbonate_calcs()[2]

    # --- kL Guesser Tab Logic ---
    @output
    @render.data_frame
    def pfas_properties_table(): return pfas_properties()

    kl_estimates = reactive.Value(pd.DataFrame())
    @reactive.Effect
    @reactive.event(input.estimate_kl)
    def _():
        df = pfas_properties().copy()
        req(not df.empty)
        t_k = input.temp() + 273.15
        viscosity = np.exp(-24.71 + (4209/t_k) + 0.04527 * t_k - (3.376e-5 * t_k**2)) / 100
        t2 = t_k / 324.65
        density = 0.98396*(-1.41768 + 8.97665*t2 - 12.2755*t2**2 + 7.45844*t2**3 - 1.73849*t2**4)
        mu1 = viscosity * 100
        
        df['kL Estimate (cm/s)'] = df.apply(lambda row:
            ( (2 + 0.644 * ( (input.Vv() / input.EBEDv()) * (2*input.rbv()) * (density / viscosity) )**(1/2) * (viscosity / density / (13.26e-5 * (mu1 ** -1.14) * (float(row["MolarVol (cm^3/mol)"]) ** -0.589)))**(1/3)) * (1 + 1.5 * (1- input.EBEDv())) ) * (13.26e-5 * (mu1 ** -1.14) * (float(row["MolarVol (cm^3/mol)"]) ** -0.589)) / (2*input.rbv()),
            axis=1
        )
        kl_estimates.set(df[['kL Estimate (cm/s)']])

    @output
    @render.data_frame
    def kl_estimates_table(): return kl_estimates().round(5)

    # Process model output for plotting
    @reactive.Calc
    def processed_output():
        results = model_results()
        if results is None: return None
        
        t_out, x_out = results
        ions_df = app_data()["ions"]
        cin_df = app_data()["cin"]
        effluent_df = app_data()["effluent"]
        NION = len(ions_df)

        # Extract outlet concentrations
        outlet_conc = x_out[:, -1, :, -1] # time, liquid_phase, ions, outlet_node
        
        # Reshape for plotting
        df = pd.DataFrame(outlet_conc, columns=ions_df['name'])
        df['hours'] = t_out
        
        # Convert to long format
        df_long = df.melt(id_vars='hours', var_name='name', value_name='conc_meq')

        # Convert units based on output selection
        output_unit = input.OCunits()
        if output_unit == "c/c0":
            c0_meq = cin_correct(ions_df, cin_df.iloc[[0]]).drop(columns='time').iloc[0]
            df_long['conc'] = df_long.apply(lambda row: row['conc_meq'] / c0_meq[row['name']] if c0_meq[row['name']] != 0 else 0, axis=1)
        else: # mg/L, ug/L, ng/L
            df_mgl = df.copy()
            for name in df_mgl.columns:
                if name != 'hours':
                    ion_info = ions_df[ions_df['name'] == name].iloc[0]
                    df_mgl[name] *= ion_info['mw'] / ion_info['valence']
            
            df_mgl_long = df_mgl.melt(id_vars='hours', var_name='name', value_name='conc')
            df_mgl_long['conc'] /= MASS_CONV[output_unit]
            df_long = df_mgl_long
            
        # Convert time units
        time_unit = input.timeunits()
        if time_unit == "Bed Volumes (x1000)":
            # Simplified get_bv_in_sec logic
            L_cm = input.Lv() * LENGTH_CONV[input.LengthUnits()]
            V_cms = input.Vv() * VELOCITY_CONV[input.VelocityUnits()]
            bv_sec = L_cm / V_cms
            df_long['hours'] /= (bv_sec / 3600) / 1000
        else:
            df_long['hours'] /= (TIME_CONV[time_unit] / 3600)
            
        # Process effluent and influent similarly
        effluent_processed = pd.DataFrame()
        # print('effluent_df',effluent_df)
        # print('*****')
        if input.effluentdata() and not effluent_df.empty:
            effluent_long = effluent_df.melt(id_vars='time', var_name='name', value_name='conc')
            effluent_long = effluent_long.rename(columns={'time': 'hours'})
            effluent_long['name'] = effluent_long['name'] + "_effluent"
            effluent_processed = effluent_long

        influent_processed = pd.DataFrame()
        if input.influentdata() and not cin_df.empty:
            influent_long = cin_df.melt(id_vars='time', var_name='name', value_name='conc')
            influent_long = influent_long.rename(columns={'time': 'hours'})
            influent_long['name'] = influent_long['name'] + "_influent"
            influent_processed = influent_long

        return df_long, effluent_processed, influent_processed

    # Render plots
    @output
    @render_widget
    def plot_counterions():
        res = processed_output()
        if res is None: return
        computed, effluent, influent = res
        
        counter_ions = ["CHLORIDE", "SULFATE", "NITRATE", "BICARBONATE"]
        computed_sub = computed[computed['name'].isin(counter_ions)] if input.computeddata() else pd.DataFrame()
        effluent_sub = effluent[effluent['name'].str.contains('|'.join(counter_ions))] if input.effluentdata() else pd.DataFrame()
        influent_sub = influent[influent['name'].str.contains('|'.join(counter_ions))] if input.influentdata() else pd.DataFrame()
        
        return create_plotly(
            computed_sub, effluent_sub, influent_sub,
            title="Major Inorganic Ion Concentrations",
            y_axis_title=f"Concentration ({input.OCunits()})",
            x_axis_title=f"Time ({input.timeunits()})"
        )

    @output
    @render_widget
    def plot_other_ions():
        res = processed_output()
        if res is None: return
        computed, effluent, influent = res
        
        counter_ions = ["CHLORIDE", "SULFATE", "NITRATE", "BICARBONATE"]
        computed_sub = computed[~computed['name'].isin(counter_ions)] if input.computeddata() else pd.DataFrame()
        effluent_sub = effluent[~effluent['name'].str.contains('|'.join(counter_ions))] if input.effluentdata() else pd.DataFrame()
        influent_sub = influent[~influent['name'].str.contains('|'.join(counter_ions))] if input.influentdata() else pd.DataFrame()
        
        # print('res=\n',res,'results df \n', counter_ions,computed_sub,effluent_sub,influent_sub)
        return create_plotly(
            computed_sub, effluent_sub, influent_sub,
            title="Additional Ionic Species Concentrations (e.g., PFAS)",
            y_axis_title=f"Concentration ({input.OCunits()})",
            x_axis_title=f"Time ({input.timeunits()})"
        )
        
    @render.download(filename=lambda: f"data-output-{pd.Timestamp.now().strftime('%Y%m%d')}.xlsx")
    def save_button():
        results = model_results()
        if results is None: 
            yield b"" # Return empty if no results
            return
        
        t_out, x_out = results
        ions_df = app_data()["ions"]
        outlet_conc = x_out[:, -1, :, -1]
        
        output_df = pd.DataFrame(outlet_conc, columns=ions_df['name'])
        output_df.insert(0, "time_hours", t_out)

        from io import BytesIO
        with BytesIO() as buf:
            with pd.ExcelWriter(buf) as writer:
                app_data()["params"].to_excel(writer, sheet_name="params", index=False)
                ions_df.to_excel(writer, sheet_name="ions", index=False)
                app_data()["cin"].to_excel(writer, sheet_name="Cin", index=False)
                app_data()["effluent"].to_excel(writer, sheet_name="effluent", index=False)
                output_df.to_excel(writer, sheet_name="model_results", index=False)
            yield buf.getvalue()

app = App(app_ui, server)
